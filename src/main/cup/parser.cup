/*
    This code is part of the compiler course in hua university
*/

import java_cup.runtime.Symbol;
import ast.*;
import dit.hua.compiler.ast.expressions.*;
import dit.hua.compiler.ast.definitions.*;
import dit.hua.compiler.ast.statements.*;
import dit.hua.compiler.ast.types.*;
import java.util.*;

parser code
{:
        @Override
        public void report_error(String message, Object info){
                Symbol sym = (Symbol) info;
                System.out.println ("Syntax error: "+message);
                System.out.println("Line: "+sym.left);
                System.out.println ("Column: "+sym.right);
                System.out.println("Token value: "+sym.value);
        }      

        // Helper method to create a list with a single element
        public static <T> List<T> createList(T element) {
            List<T> list = new ArrayList<>();
            if (element != null) {
                list.add(element);
            }
            return list;
        }

        // Helper method to add element to existing list
        public static <T> List<T> addToList(List<T> list, T element) {
            if (list == null) {
                list = new ArrayList<>();
            }
            if (element != null) {
                list.add(element);
            }
            return list;
        }

        // Helper method to create empty list
        public static <T> List<T> createEmptyList() {
            return new ArrayList<T>();
        }

        // Helper method to build array type from base type and dimensions
        public static Type buildArrayType(Type baseType, List<Integer> dimensions) {
            if (dimensions == null || dimensions.isEmpty()) {
                return baseType;
            }
            return new ArrayType(baseType, dimensions);
        }

        // Helper method to extract parameters from fpar_def
        public static List<Parameter> createParametersFromDef(boolean isRef, List<String> names, Type type) {
            List<Parameter> params = new ArrayList<>();
            for (String name : names) {
                params.add(new Parameter(name, type, isRef));
            }
            return params;
        }
:};

//Terminal reserved words
terminal AND, FUN, NOTHING, VAR, CHAR, IF, OR, WHILE, DIV, INT;
terminal REF, DO, MOD, RETURN, ELSE, NOT, THEN;

//Terminal identifiers
terminal java.lang.String IDENTIFIER;

//Terminal Integers
terminal java.lang.Integer INT_LITERAL;

//Terminal operators
terminal PLUS, MINUS, MULTIPLY;
terminal NEQUAL, EQUALS, LT, GT, LE, GE;

//Terminal spacers
terminal LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal LCURLY, RCURLY, COMMA, SEMICOLON, COLON, PLIKE;

//Terminal for string
terminal java.lang.String STRING_LITERAL;

//Terminal for single constant characters
// terminal CHAR_LITERAL;
terminal java.lang.String CHAR_LITERAL;
//terminal java.lang.Character CHAR_LITERAL

//Terminal only for priority 
terminal UMINUS, UPLUS;


non terminal Program program;
non terminal FunctionDefinition func_def;
non terminal HeaderInfo header;
non terminal List<LocalDefinition> local_def;
non terminal BlockStatement block;
non terminal List<LocalDefinition> local_def_list;
non terminal ParameterDefInfo fpar_def;
non terminal Type ret_type;
non terminal List<ParameterDefInfo> fpar_def_list;
non terminal Boolean maybe_ref;
non terminal Type fpar_type;
non terminal List<String> id_list;
non terminal Type data_type;
non terminal Type type;
non terminal List<Integer> int_literal_list;
non terminal FunctionDeclaration func_decl;
non terminal VariableDeclaration var_def;
non terminal Statement stmt;
non terminal LValue l_value;
non terminal Expression expr;
non terminal FunctionCallInfo func_call;
non terminal Condition cond;
non terminal Statement maybe_stmt;
non terminal Expression maybe_expr;
non terminal List<Statement> stmt_list;
non terminal List<Expression> maybe_expr_2;
non terminal List<Expression> expr_list;

precedence left OR;
precedence left AND;
precedence nonassoc NOT;
precedence nonassoc LT, GT, LE, GE, NEQUAL, EQUALS; 
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIV, MOD;
precedence right UMINUS, UPLUS;


start with program;

program ::= func_def:fd
        {:RESULT = new Program(fd);:}
        ;
        
func_def ::= header:h local_def_list:ldl block:b
        {:RESULT = new FunctionDefinition(h.name, h.parameters, h.returnType, ldl, b);:}
        ;

local_def_list ::= /*Zero or more*/     
                {:RESULT = createEmptyList();:}
                | local_def_list:list local_def:ld
                {:RESULT = addToList(list, ld);:}
                ;

header ::= FUN IDENTIFIER:name LPAREN fpar_def:fpd fpar_def_list:fpdl RPAREN COLON ret_type:rt
        {:
              List<Parameter> params = createParametersFromDef(fpd.isRef, fpd.names, fpd.type);
              for (ParameterDefInfo info : fpdl){
                params.addAll(createParametersFromDef(info.isRef, info.names, info.type));
              }  
              RESULT = new HeaderInfo(name, params, rt);
        :}
        | FUN IDENTIFIER:name LPAREN RPAREN COLON ret_type:rt
        {:RESULT = new HeaderInfo(name, createEmptyList(), rt);:}
        ;
 

fpar_def_list ::= /*Empty */
                {:RESULT = createEmptyList();:}
                |fpar_def_list:list SEMICOLON fpar_def:fpd
                {:RESULT = addToList(list, fpd);:}
                ;

fpar_def ::= maybe_ref:ref IDENTIFIER:name id_list:names COLON fpar_type:type
        {:
                List<String> allNames = createList(name);
                allNames.addAll(names);
                RESULT = new ParameterDefInfo(ref, allNames, type);
        :}
        ;

maybe_ref ::= /*Empty*/
            {:RESULT = false;:}
            |REF
            {:RESULT = true;:}
            ;

id_list ::= /*Empty*/
          {:RESULT = createEmptyList();:}
          |id_list:list COMMA IDENTIFIER:name
          {:RESULT = addToList(list, name);:}
          ;  
    
data_type ::= INT       
            {:RESULT = new IntType();:}
            | CHAR      
            {:RESULT = new CharType();:}
            ;
        
type ::= data_type:dt int_literal_list:dims
        {:RESULT = buildArrayType(dt, dims);:}
        ;

int_literal_list ::= /*Empty*/
                    {:RESULT = createEmptyList();:}
                    |int_literal_list:list LBRACKET INT_LITERAL:dim RBRACKET
                    {:RESULT = addToList(list, dim);:}
                    ;

ret_type ::= data_type:dt
            {:RESULT = dt;:}
            |NOTHING
            {:RESULT = new NothingType();:}
            ;

fpar_type ::=  data_type:dt
                {:RESULT = dt;:}
                | data_type:dt LBRACKET RBRACKET
                {:RESULT = new ArrayType(dt, createEmptyList());:}
                |data_type:dt LBRACKET RBRACKET LBRACKET INT_LITERAL:dim RBRACKET
                {:RESULT = new ArrayType(dt, createList(dim));:}
                | data_type:dt LBRACKET INT_LITERAL:dim RBRACKET
                {:RESULT = new ArrayType(dt, createList(dim));:}
                | data_type:dt LBRACKET INT_LITERAL:dim1 RBRACKET LBRACKET INT_LITERAL:dim2 RBRACKET
                {:
                        List<Integer> dims = createList(dim1);
                        dims.add(dim2);
                        RESULT = new ArrayType(dt, dims);
                :}
                ;
             
local_def ::= func_def:fd
            {:RESULT = fd;:}    
            |func_decl:fdcl
            {:RESULT = fdcl;:}
            |var_def:vd
            {:RESULT = vd;:}
            ;

var_def ::= VAR IDENTIFIER:name id_list:names COLON type:t SEMICOLON
        {:
                List<String> allNames = createList(name);
                allNames.addAll(names);
                RESULT = new VariableDeclaration(allNames, t);
        :}
        ;

func_decl ::= header:h SEMICOLON
        {:RESULT = new FunctionDeclaration(h.name, h.parameters, h.returnType);:}
        ;

stmt ::= SEMICOLON
        {:RESULT = new EmptyStatement();:}
        |l_value:lv PLIKE expr:e SEMICOLON
        {:RESULT = new AssignmentStatement(lv, e);:}
        |block:b
        {:RESULT = b;:}
        |func_call:fc SEMICOLON
        {:RESULT = new FunctionCallStatement(fc.name, fc.arguments);:}
        |IF cond:c THEN stmt:s1 maybe_stmt:s2
        {:RESULT = new IfStatement(c, s1, s2);:}
        |WHILE cond:c DO stmt:s
        {:RESULT = new WhileStatement(c, s);:}
        |RETURN maybe_expr:e SEMICOLON
        {:RESULT = new ReturnStatement(e);:}
        ;

maybe_stmt ::= /*Empty*/
            {:RESULT = null;:}
            |ELSE stmt:s
            {:RESULT = s;:}
            ;

maybe_expr ::= /*Empty*/
            {:RESULT = null;:}
            |expr:e
            {:RESULT = e;:}
            ;

block ::= LCURLY stmt_list:stmts RCURLY
          {:RESULT = new BlockStatement(stmts);:}
          ;

stmt_list ::= /*Empty*/
            {:RESULT = createEmptyList();:}
            |stmt_list:list stmt:s
            {:RESULT = addToList(list, s);:}
            ;

maybe_expr_2 ::= /*Empty*/
                {:RESULT = createEmptyList();:}
                |expr:e expr_list:list
                {:
                        List<Expression> args = createList(e);
                        args.addAll(list);
                        RESULT = args;
                :}
                ;

func_call ::= IDENTIFIER:name LPAREN maybe_expr_2:args RPAREN
             {:RESULT = new FunctionCallInfo(name, args);:}
             ;

expr_list ::= /*Empty*/
            {:RESULT = createEmptyList();:}
            |expr_list:list COMMA expr:e
            {:RESULT = addToList(list, e);:}
            ;

l_value ::= IDENTIFIER:name
           {:RESULT = new IdentifierLValue(name);:}
           |STRING_LITERAL:str
           {:RESULT = new StringLiteralLValue(str);:}
           |l_value:lv LBRACKET expr:idx RBRACKET
           {:RESULT = new ArrayAccessLValue(lv, idx);:}
           ; 

expr ::= INT_LITERAL:l                          
        {:RESULT = new IntegerLiteralExpression(l);:}
        |CHAR_LITERAL:cl                        
        {:RESULT = new CharLiteralExpression(cl);:}
        |l_value:lv
        {:RESULT = lv;:}
        |func_call:fc
        {:RESULT = new FunctionCallExpression(fc.name, fc.arguments);:}
        |LPAREN expr:exp RPAREN                 
        {:RESULT = new ParenthesisExpresiion(exp);:}
        |PLUS expr:e1 %prec UPLUS               
        {:RESULT = new UnaryExpression(Operator.PLUS, e1);:}
        |MINUS expr:e1 %prec UMINUS             
        {:RESULT = new UnaryExpression(Operator.MINUS, e1);:}
        |expr:e1 PLUS expr:e2                   
        {:RESULT = new BinaryExpression(Operator.PLUS, e1, e2);:}
        |expr:e1 MINUS expr:e2                  
        {:RESULT = new BinaryExpression(Operator.MINUS, e1, e2);:}
        |expr:e1 MULTIPLY expr:e2               
        {:RESULT = new BinaryExpression(Operator.MULTIPLY, e1, e2);:}
        |expr:e1 MOD expr:e2                    
        {:RESULT = new BinaryExpression(Operator.MOD, e1, e2);:}
        ;

cond ::= LPAREN cond:c1 RPAREN
        {:RESULT = new ParenthesisCondition(c1);:}               
        |NOT cond:c1                                  
        {:RESULT = new LogicalCondition(LogicalOperator.NOT, c1);:} 
        |cond:c1 AND cond:c2                          
        {:RESULT = new LogicalCondition(LogicalOperator.AND, c1, c2);:} 
        |cond:c1 OR cond:c2                           
        {:RESULT = new LogicalCondition(LogicalOperator.OR, c1, c2);:}  
        |expr:e1 EQUALS expr:e2                       
        {:RESULT = new BinaryCondition(Operator.EQUALS, e1, e2);:}
        |expr:e1 NEQUAL expr:e2                       
        {:RESULT = new BinaryCondition(Operator.NEQUAL, e1, e2);:} 
        |expr:e1 LT expr:e2                           
        {:RESULT = new BinaryCondition(Operator.LT, e1, e2);:}
        |expr:e1 GT expr:e2                           
        {:RESULT = new BinaryCondition(Operator.GT, e1, e2);:}
        |expr:e1 LE expr:e2                           
        {:RESULT = new BinaryCondition(Operator.LE, e1, e2);:}
        |expr:e1 GE expr:e2                           
        {:RESULT = new BinaryCondition(Operator.GE, e1, e2);:}
        ;