/*
    This code is part of the compiler course in hua university
*/

import java_cup.runtime.Symbol;
import ast.*;

parser code
{:
        @Override
        public void report_error(String message, Object info){
                Symbol sym = (Symbol) info;
                System.out.println ("Syntax error: "+message);
                System.out.println("Line: "+sym.left);
                System.out.println ("Column: "+sym.right);
                System.out.println("Token value: "+sym.value);
        }       
:};

//Terminal reserved words
terminal AND, FUN, NOTHING, VAR, CHAR, IF, OR, WHILE, DIV, INT;
terminal REF, DO, MOD, RETURN, ELSE, NOT, THEN;

//Terminal identifiers
terminal java.lang.String IDENTIFIER;

//Terminal Integers
terminal java.lang.Integer INT_LITERAL;

//Terminal operators
terminal PLUS, MINUS, MULTIPLY;
terminal NEQUAL, EQUALS, LT, GT, LE, GE;

//Terminal spacers
terminal LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal LCURLY, RCURLY, COMMA, SEMICOLON, COLON, PLIKE;

//Terminal for string
terminal java.lang.String STRING_LITERAL;

//Terminal for single constant characters
terminal CHAR_LITERAL;

//Terminal only for priority 
terminal UMINUS, UPLUS;


non terminal Program program;
non terminal func_def;
non terminal header;
non terminal local_def;
non terminal block;
non terminal local_def_list;
non terminal fpar_def;
non terminal ret_type;
non terminal fpar_def_list;
non terminal maybe_ref;
non terminal fpar_type;
non terminal id_list;
non terminal data_type;
non terminal type;
non terminal int_literal_list;
non terminal func_decl;
non terminal var_def;
non terminal stmt;
non terminal l_value;
non terminal Expression expr;
non terminal func_call;
non terminal Condition cond;
non terminal maybe_stmt;
non terminal maybe_expr;
non terminal stmt_list;
non terminal maybe_expr_2;
non terminal expr_list;


precedence left OR;
precedence left AND;
precedence nonassoc NOT;
precedence nonassoc LT, GT, LE, GE, NEQUAL, EQUALS; 
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIV, MOD;
precedence right UMINUS, UPLUS;


start with program;

program ::= func_def;
        
func_def ::= header local_def_list block;

local_def_list ::= /*Zero or more*/
                | local_def_list local_def
                ;

header ::= FUN IDENTIFIER LPAREN fpar_def fpar_def_list RPAREN COLON ret_type
        | FUN IDENTIFIER LPAREN RPAREN COLON ret_type 
        ;
 

fpar_def_list ::= /*Empty */
                |fpar_def_list SEMICOLON fpar_def
                ;

fpar_def ::= maybe_ref IDENTIFIER id_list COLON fpar_type;

maybe_ref ::= /*Empty*/
            |REF
            ;

id_list ::= /*Empty*/ 
          |id_list COMMA IDENTIFIER
          ;  
    
data_type ::= INT
            | CHAR
            ;
        
type ::= data_type int_literal_list;

int_literal_list ::= /*Empty*/
                    |int_literal_list LBRACKET INT_LITERAL RBRACKET
                    ;

ret_type ::= data_type
            |NOTHING
            ;

fpar_type ::=  data_type
                | data_type LBRACKET RBRACKET
                |data_type LBRACKET RBRACKET LBRACKET INT_LITERAL RBRACKET
                | data_type LBRACKET INT_LITERAL RBRACKET
                | data_type LBRACKET INT_LITERAL RBRACKET LBRACKET INT_LITERAL RBRACKET
                ;
             
local_def ::= func_def
            |func_decl
            |var_def
            ;

var_def ::= VAR IDENTIFIER id_list COLON type SEMICOLON;

func_decl ::= header SEMICOLON;

stmt ::= SEMICOLON
        |l_value PLIKE expr SEMICOLON
        |block
        |func_call SEMICOLON
        |IF cond THEN stmt maybe_stmt
        |WHILE cond DO stmt
        |RETURN maybe_expr SEMICOLON
        ;

maybe_stmt ::= /*Empty*/
            |ELSE stmt
            ;

maybe_expr ::= /*Empty*/
            |expr
            ;

block ::= LCURLY stmt_list RCURLY;

stmt_list ::= /*Empty*/
            |stmt_list stmt
            ;

maybe_expr_2 ::= /*Empty*/
                |expr expr_list
                ;

func_call ::= IDENTIFIER LPAREN maybe_expr_2 RPAREN;

expr_list ::= /*Empty*/
            |expr_list COMMA expr
            ;

l_value ::= IDENTIFIER
           |STRING_LITERAL
           |l_value LBRACKET expr RBRACKET
           ; 

expr ::= INT_LITERAL:l                          {:RESULT = new IntegerLiteralExpression(l);:}
        |CHAR_LITERAL:cl                        {:RESULT = new CharLiteralExpression(cl);:}
        |l_value
        |func_call
        |LPAREN expr:exp RPAREN                 {:RESULT = new ParenthesisExpresiion(exp);:}
        |PLUS expr:e1 %prec UPLUS               {:RESULT = new UnaryExpression(Operator.PLUS, e1);:}
        |MINUS expr:e1 %prec UMINUS             {:RESULT = new UnaryExpression(Operator.MINUS, e2);:}
        |expr:e1 PLUS expr:e2                   {:RESULT = new BinaryExpression(Operator.PLUS, e1, e2);:}
        |expr:e1 MINUS expr:e2                  {:RESULT = new BinaryExpression(Operator.MINUS, e1, e2);:}
        |expr:e1 MULTIPLY expr:e2               {:RESULT = new BinaryExpression(Operator.MULTIPLY, e1, e2);:}
        |expr:e1 MOD expr:e2                    {:RESULT = new BinaryExpression(Operator.MOD, e1, e2);:}
        ;

cond ::= LPAREN cond:c1 RPAREN                        {:RESULT = new ParenthesisCondition(c1);:}               
        |NOT cond:c1                                  {:RESULT = new LogicalCondition(LogicalOperator.NOT, c1);:} 
        |cond:c1 AND cond:c2                          {:RESULT = new LogicalCondition(LogicalOperator.AND, c1, c2);:} 
        |cond:c1 OR cond:c2                           {:RESULT = new LogicalCondition(LogicalOperator.OR), c1, c2;:}  
        |expr:e1 EQUALS expr:e2                       {:RESULT = new BinaryCondition(Operator.EQUALS, e1, e2);:}
        |expr:e1 NEQUAL expr:e2                       {:RESULT = new BinaryCondition(Operator.NEQUAL, e1, e2);:} 
        |expr:e1 LT expr:e2                           {:RESULT = new BinaryCondition(Operator.LT, e1, e2);:}
        |expr:e1 GT expr:e2                           {:RESULT = new BinaryCondition(Operator.GT, e1, e2);:}
        |expr:e1 LE expr:e2                           {:RESULT = new BinaryCondition(Operator.LE, e1, e2);:}
        |expr:e1 GE expr:e2                           {:RESULT = new BinaryCondition(Operator.GE), e1, e2;:}
        ;